% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sig}
\alias{sig}
\title{Compute Path Signature}
\usage{
sig(path, m, flat = TRUE)
}
\arguments{
\item{path}{A numeric matrix with dimensions (n x d), where n is the number
of time steps and d is the path dimension. Each row represents a time point
and each column represents a dimension (standard time series format).}

\item{m}{An integer specifying the maximum order of the signature (1 <= m <= 10).}

\item{flat}{A logical value. If TRUE (default), returns a flattened numeric vector
containing all signature levels concatenated. If FALSE, returns a list with
each signature level as a separate element.}
}
\value{
If flat=TRUE, returns a numeric vector of length sum(d^k) for k=1 to m.
If flat=FALSE, returns a list of length m, where element k contains a numeric
vector of length d^k representing the k-th order signature.
}
\description{
Computes the signature of a path up to a specified order. The signature is a
sequence of iterated integrals that characterizes the path and has useful
properties for machine learning, quantitative finance, and time series analysis.
}
\details{
The signature computation uses Chen's identity for efficient combination of
path segments. The function includes OpenMP parallelization and optimized
memory management.

Memory usage grows as sum(d^k) for k=1 to m. For large dimensions or orders,
consider using lower values to avoid memory issues.

The input follows standard time series convention: rows are time points,
columns are variables/dimensions.
}
\examples{
\dontrun{
# Create a simple 2D path (100 time points, 2 dimensions)
path <- matrix(rnorm(200), ncol = 2)

# Or using cumulative sums for more realistic paths
path <- apply(matrix(rnorm(200), ncol = 2), 2, cumsum)

# Compute signature up to order 3
sig_flat <- sig(path, m = 3, flat = TRUE)
sig_list <- sig(path, m = 3, flat = FALSE)
}

}
